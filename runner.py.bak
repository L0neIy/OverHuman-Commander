import sys
import os
import time
from dotenv import load_dotenv

# --- fix path ---
project_path = os.path.dirname(os.path.abspath(__file__))
if project_path not in sys.path:
    sys.path.insert(0, project_path)

# --- imports ---
from config import CFG
from broker import CCXTBroker
from regime import RegimeDetector
from experts.trend import TrendFollower
from experts.mean_revert import MeanRevert
from experts.breakout import Breakout
from experts.pullback import TrendPullback
from experts.vol_squeeze import VolSqueezeBreakout
from meta import MetaLearner
from risk import RiskGovernor
from utils import atr_wilder
from selectors import rank_by_momentum, pick_diversified
from logger import CommanderLogger

logger = CommanderLogger()


# --- load env ---
load_dotenv()

def main():
    # --- exchange + API ---
    ex_name = os.getenv('EXCHANGE', CFG.data.exchange)
    api_key = os.getenv('API_KEY')
    api_secret = os.getenv('API_SECRET')
    dry_run = os.getenv('DRY_RUN', 'true').lower() == 'true'
    sandbox = os.getenv('SANDBOX', 'false').lower() == 'true'

    # --- symbols & timeframe ---
    symbols_env = os.getenv('SYMBOLS')
    symbols = [s.strip() for s in symbols_env.split(',')] if symbols_env else list(CFG.data.symbols)
    symbols = [s.replace("/", "") for s in symbols]
    timeframe = os.getenv('TIMEFRAME', CFG.data.timeframe)

    print(f"Commander live (multi) DryRun={dry_run} Sandbox={sandbox} Symbols={symbols} Timeframe={timeframe}")

    broker = CCXTBroker(ex_name, api_key, api_secret, sandbox=sandbox)

    reg = RegimeDetector(CFG.regime)
    experts = [TrendFollower(), MeanRevert(), Breakout(), TrendPullback(), VolSqueezeBreakout()]
    meta = MetaLearner(CFG.meta, [e.name for e in experts])
    risk = RiskGovernor(CFG.risk)

    state = {s: {"entry": None, "pos": 0.0} for s in symbols}

    while True:
        try:
            # fetch fresh windows
            data = {}
            for s in symbols:
                df = broker.fetch_ohlcv(s, timeframe, limit=max(CFG.data.lookback, 220))
                if df is None or df.empty:
                    continue
                df['atr14'] = atr_wilder(df, 14)
                df['date'] = df['timestamp'].dt.date
                data[s] = df
                time.sleep(0.2)

            if not data:
                time.sleep(3)
                continue

            ranked = rank_by_momentum(data)
            tradables = pick_diversified(ranked, data, CFG.risk.top_k, CFG.risk.corr_threshold)

            for s in symbols:
                df = data.get(s)
                if df is None:
                    continue
                day_key = df['date'].iloc[-1]
                risk.reset_day(day_key)

                price = float(df['close'].iloc[-1])
                atrv = float(df['atr14'].iloc[-1] or 0.0)

                direction = 0
                strength = 0.0
                if s in tradables:
                    rfeat = reg.detect(df).iloc[-1]
                    w_reg = {
                        'trend': float(rfeat['w_trend']),
                        'mean_revert': float(rfeat['w_range']),
                        'breakout': float(rfeat['w_breakout'])
                    }
                    ssum = sum(w_reg.values()) or 1.0
                    w_reg = {k: v/ssum for k, v in w_reg.items()}

                    sigs = {}
                    for e in experts:
                        sgl = e.signal(df)
                        w = w_reg.get(e.name, 0.0) * meta.get_weight(e.name)
                        sigs[e.name] = (sgl.direction,
                                        max(0.0, min(1.0, sgl.strength)) * w,
                                        sgl.reason)

                    net = sum(d * st for (d, st, _) in sigs.values())
                    direction = 1 if net > 0.05 else (-1 if net < -0.05 else 0)
                    strength = min(1.0, abs(net))

                decision = risk.decide(s, price, atrv, direction, strength)

                pos = state[s]["pos"]
                entry = state[s]["entry"]

                if pos != 0.0 and entry is not None:
                    pnl_frac = (price/entry - 1.0) * (1 if pos > 0 else -1)
                    risk.register_pnl(pnl_frac * abs(pos))
                    if (decision is None
                        or (decision.side == 'buy' and pos < 0)
                        or (decision.side == 'sell' and pos > 0)
                        or (s not in tradables)):
                        if not dry_run:
                            broker.place_order(s, 'buy' if pos < 0 else 'sell', abs(pos))
                        state[s]['pos'] = 0.0
                        state[s]['entry'] = None
                        risk.close_position(s)

                if decision and state[s]['pos'] == 0.0 and s in tradables:
                    if not dry_run:
                        broker.place_order(s, decision.side, decision.size)
                    state[s]['pos'] = decision.size if decision.side == 'buy' else -decision.size
                    state[s]['entry'] = price
                    risk.open_position(s, state[s]['pos'], price)

            time.sleep(5)

        except Exception as e:
            print("Runner error:", e)
            time.sleep(5)

if __name__ == "__main__":
    main()
